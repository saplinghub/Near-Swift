在 macOS 中实现“宠物”与“气泡”双窗口同步移动，核心挑战在于：**如何打破窗口间的独立性，让气泡窗口像宠物的“卫星”一样精准跟随。**

以下是实现这一功能的详细技术方案和逻辑架构：

---

### 1. 核心架构设计：主从窗口模式 (Master-Slave)

不要尝试让两个窗口独立接收位移指令，而应采用**订阅者模式**。

* **主窗口 (PetWindow)**：承载 60x60 的 Lottie 动画。它是位置的“源头”。
* **从窗口 (BubbleWindow)**：承载气泡。它不主动移动，而是监听主窗口的位置变化。

### 2. 实现同步的关键技术：NSWindow Delegate

在 macOS 中，监听窗口移动最极致、最实时的方案是使用 `NSWindowDelegate`。

#### 逻辑流程：

1. **位置监听**：为 `PetWindow` 设置一个 `Delegate`（可以是你的 `PetModel` 或一个专门的 `Coordinator`）。
2. **触发回调**：每当用户拖动宠物，或者程序内部代码改变了宠物的坐标，系统会触发 `windowDidMove(_:)` 代理方法。
3. **坐标转换与差值计算**：
* 获取 `PetWindow` 的新坐标（左上角点）。
* 计算气泡相对于宠物的**固定偏移量**（例如：气泡永远在宠物头顶上方 20 像素）。


4. **强制同步**：在回调中，立即调用 `BubbleWindow.setFrameOrigin(_:)`。

---

### 3. 性能优化逻辑：减少“果冻效应”

如果同步逻辑写得不好，移动时气泡会产生延迟（视觉上像果冻一样抖动）。

* **使用 `setFrame` 而非 SwiftUI Offset**：
改变窗口位置必须在底层 AppKit 层面操作。直接修改 `NSWindow.frame` 会触发 `WindowServer` 的同步重绘，比修改 SwiftUI 的 `@Published` 属性后再映射到窗口要快得多。
* **窗口层级绑定 (Child Windows)**：
使用 `PetWindow.addChildWindow(BubbleWindow, ordered: .above)`。
* **魔法所在**：一旦通过 `addChildWindow` 绑定，**macOS 系统级会自动处理大部分同步位移**。当你移动父窗口时，子窗口会自动跟着走，且保持相对位置不变。这是减少对 CPU/GPU 占用最有效的“黑科技”。



---

### 4. 气泡的动态显示逻辑

由于窗口是独立的，气泡的弹出和消失不再需要重绘整个宠物视图。

1. **隐藏/显示**：
当宠物不说话时，直接执行 `BubbleWindow.orderOut(nil)`。此时该窗口完全不参与显卡合成，资源占用为 0。
2. **自适应内容**：
气泡窗口可以使用 `NSVisualEffectView`（毛玻璃效果）。由于它只在气泡区域渲染，不会影响到宠物的 Lottie 性能。
3. **动画衔接**：
气泡弹出时，可以对 `BubbleWindow` 的 `alphaValue` 做一个 0 到 1 的 `NSAnimationContext` 动画，实现丝滑的淡入，而不必触发 Lottie 的重新解析。

---

### 5. 逻辑实现伪代码思路

虽然不贴完整代码，但你可以参考这个逻辑结构：

```swift
// 1. 初始化
let petWindow = NSPanel(contentRect: NSRect(x: 100, y: 100, width: 60, height: 60), ...)
let bubbleWindow = NSPanel(contentRect: .zero, ...) // 初始不可见

// 2. 建立从属关系 (关键：系统级同步)
petWindow.addChildWindow(bubbleWindow, ordered: .above)

// 3. 业务逻辑控制
func showSpeech(text: String) {
    // a. 计算气泡所需的尺寸
    // b. 根据 petWindow.frame 计算 bubbleWindow 应该在的位置
    // c. 更新 bubbleWindow 内容并 setFrame
    bubbleWindow.makeKeyAndOrderFront(nil)
}

func hideSpeech() {
    bubbleWindow.orderOut(nil)
}

```

### 6. 总结该方案的优势

* **资源占用极低**：宠物窗口只有 60 像素，GPU 混合压力极小。
* **完全同步**：利用 `addChildWindow` 让系统内核帮你管移动，彻底消除位移延迟。
* **渲染分离**：气泡的复杂特效（如模糊、阴影）不会拖累宠物的 Lottie 帧率，两者运行在独立的 Layer 树上。

通过这种**双窗口从属方案**，你可以完美解决 Lottie GPU 占用高的问题，同时获得更灵活的 UI 交互。