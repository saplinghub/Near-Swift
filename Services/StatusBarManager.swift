import Cocoa
import SwiftUI
import Combine

class StatusBarManager: NSObject, NSWindowDelegate, NSMenuDelegate {
    static var shared: StatusBarManager?
    
    private var statusItem: NSStatusItem
    private var window: NSWindow?
    private var countdownManager: CountdownManager
    private var aiService: AIService
    private var storageManager: StorageManager
    private var systemMonitor: SystemMonitor
    private var weatherService: WeatherService
    private var eventMonitor: Any?
    private var isWindowVisible = false
    
    // Animation
    private var fanCGImages: [CGImage] = []
    private var iconLayer: CALayer?
    private var cancellables = Set<AnyCancellable>()

    init(countdownManager: CountdownManager, aiService: AIService, storageManager: StorageManager, systemMonitor: SystemMonitor) {
        self.countdownManager = countdownManager
        self.aiService = aiService
        self.storageManager = storageManager
        self.systemMonitor = systemMonitor
        self.weatherService = WeatherService.shared
        self.statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        super.init()
        StatusBarManager.shared = self
        
        setupStatusItem()
        loadFanFrames()
        setupAnimationLayer()
        setupBindings()
        
        // Initial Sync
        updatePinnedTitle()
        
        // Initial Sync
        updatePinnedTitle()
    }
    
    private func setupStatusItem() {
        if let button = statusItem.button {
            // Use a transparent image to reserve layout space (18x18)
            // This ensures text is positioned correctly to the right of our custom layer
            let placeholder = NSImage(size: NSSize(width: 18, height: 18))
            placeholder.isTemplate = false
            button.image = placeholder
            
            button.action = #selector(toggleWindow)
            button.target = self
            button.imagePosition = .imageLeft
            
            // Enable right-click menu
            button.sendAction(on: [.leftMouseDown, .rightMouseUp])
        }
        
        // Setup right-click menu
        let menu = NSMenu()
        menu.delegate = self
        
        let openItem = NSMenuItem(title: "打开主窗口", action: #selector(showWindow), keyEquivalent: "")
        openItem.tag = 1 // Tag for dynamic enable
        openItem.target = self
        menu.addItem(openItem)
        
        let hideItem = NSMenuItem(title: "隐藏主窗口", action: #selector(hideWindow), keyEquivalent: "")
        hideItem.tag = 2 // Tag for dynamic enable
        hideItem.target = self
        menu.addItem(hideItem)
        
        menu.addItem(NSMenuItem.separator())
        let quitItem = NSMenuItem(title: "退出 Near", action: #selector(quitApp), keyEquivalent: "q")
        quitItem.target = self
        menu.addItem(quitItem)
        
        // DO NOT assign to statusItem.menu (that kills left-click actions)
        self.statusMenu = menu
    }
    
    private var statusMenu: NSMenu?
    
    // MARK: - NSMenuDelegate
    func menuWillOpen(_ menu: NSMenu) {
        // Dynamically enable/disable based on window state
        for item in menu.items {
            if item.tag == 1 { // Open window
                item.isEnabled = !isWindowVisible
            } else if item.tag == 2 { // Hide window
                item.isEnabled = isWindowVisible
            }
        }
    }
    
    @objc func toggleWindow(_ sender: Any?) {
        // Check for right-click via NSApp.currentEvent
        if let event = NSApp.currentEvent, event.type == .rightMouseDown || event.type == .rightMouseUp {
            if let menu = statusMenu, let button = statusItem.button {
                menu.popUp(positioning: nil, at: NSPoint(x: 0, y: button.bounds.height + 5), in: button)
            }
            return
        }
        
        // Left-click behavior
        if isWindowVisible {
            hideWindow()
        } else {
            showWindow()
        }
    }
    
    @objc func quitApp() {
        NSApp.terminate(nil)
    }
    
    private func loadFanFrames() {
        fanCGImages.removeAll()
        
        // 1. Try to find the specific resource bundle if generated by SPM
        var resourceBundle: Bundle?
        
        if let bundlePath = Bundle.main.path(forResource: "NearCountdown_NearCountdown", ofType: "bundle") {
            resourceBundle = Bundle(path: bundlePath)
        } else {
            resourceBundle = Bundle.main
        }
        
        for i in 0...31 {
            let frameName = String(format: "fan_%02d", i)
            var image: NSImage?
            
            if let path = resourceBundle?.path(forResource: frameName, ofType: "png") {
                 image = NSImage(contentsOfFile: path)
            } else if let path = resourceBundle?.path(forResource: frameName, ofType: "png", inDirectory: "icons/fan_frames") {
                 image = NSImage(contentsOfFile: path)
            } else if let path = Bundle.main.path(forResource: frameName, ofType: "png", inDirectory: "NearCountdown_NearCountdown.bundle") {
                 image = NSImage(contentsOfFile: path)
            }
            
            if let img = image {
                // Ensure we get a valid CGImage
                if let tiffData = img.tiffRepresentation,
                   let bitmap = NSBitmapImageRep(data: tiffData),
                   let cgImage = bitmap.cgImage {
                    fanCGImages.append(cgImage)
                } else {
                     // Fallback mechanism
                    var rect = NSRect(origin: .zero, size: img.size)
                    if let cgImage = img.cgImage(forProposedRect: &rect, context: nil, hints: nil) {
                        fanCGImages.append(cgImage)
                    }
                }
            }
        }
        
        if fanCGImages.isEmpty {
            print("Error: No fan frames loaded for animation layer.")
        }
    }
    
    private func setupAnimationLayer() {
        guard !fanCGImages.isEmpty, let button = statusItem.button else { return }
        
        // Ensure UI updates happen on main thread
        DispatchQueue.main.async {
            button.wantsLayer = true
            
            // Clear existing sublayers to prevent dupes
            button.layer?.sublayers?.forEach { $0.removeFromSuperlayer() }
            
            // Create a sublayer for the icon to strictly control size and position
            let layer = CALayer()
            layer.bounds = CGRect(x: 0, y: 0, width: 18, height: 18) // Match icon size
            
            // Position: Center in the standard 22px height button
            // If placeholder is 18x18, we center on that.
            // X: 18/2 + padding (~4?) = 13.
            // Y: 22/2 = 11.
            layer.position = CGPoint(x: 13, y: 11)
            layer.contentsGravity = .resizeAspect
            
            // Important: Add to button's layer
            button.layer?.addSublayer(layer)
            self.iconLayer = layer
            
            // Set initial content for static state or speed = 0 cases
            layer.contents = self.fanCGImages.first
            
            // Create the Keyframe Animation
            let animation = CAKeyframeAnimation(keyPath: "contents")
            animation.values = self.fanCGImages
            animation.calculationMode = .discrete // Jump between frames
            animation.duration = 1.0 // 1 second per full rotation (Base speed)
            animation.repeatCount = .infinity
            animation.isRemovedOnCompletion = false
            
            layer.add(animation, forKey: "spin")
            
            // Initialize speed
            layer.speed = 1.0
        }
    }
    
    private func setupBindings() {
        // Observe changes to countdowns to update title
        countdownManager.objectWillChange
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    self?.updatePinnedTitle()
                }
            }
            .store(in: &cancellables)
            
        // Observe System CPU Usage (Changed from Temperature)
        systemMonitor.$cpuUsage
            .receive(on: DispatchQueue.main)
            .sink { [weak self] usage in
                self?.updateFanSpeed(usage: usage)
            }
            .store(in: &cancellables)
    }
    
    private func updateFanSpeed(usage: Double) {
        // CPU-Based Logic (User Request):
        // Proportional: Higher CPU = Faster Spin
        // Usage is 0.0 to 1.0
        
        guard let layer = iconLayer else { return }
        
        // 风车启用配置优先级次高：由用户手动控制开关
        if !storageManager.isWindmillEnabled {
            if layer.speed != 0.0 { layer.speed = 0.0 }
            return
        }
        
        // 闲置状态优先级最高：彻底停止动画以解除 WindowServer 渲染压力
        if PowerStateManager.shared.isIdle {
            if layer.speed != 0.0 { layer.speed = 0.0 }
            return
        }
        
        let targetSpeed: Float
        
        if usage >= 0.8 {
            targetSpeed = 3.0 // Hyper Speed
        } else if usage >= 0.5 {
            targetSpeed = 2.0 // Fast
        } else if usage >= 0.1 {
            targetSpeed = 1.0 // Normal (30 FPS)
        } else {
            targetSpeed = 0.2 // Idle / Very Slow
        }
        
        // Output speed for debugging if needed
        // print("CPU: \(usage) -> Speed: \(targetSpeed)")
        
        // Smooth update check
        if abs(layer.speed - targetSpeed) > 0.05 {
            layer.speed = targetSpeed
        }
    }
    
    /// 当设置中的风车开关发生变化时，调用此方法立即同步状态
    func updateWindmillState() {
        // 重置动画状态，通过传入当前的 CPU 占用重新计算速度
        updateFanSpeed(usage: systemMonitor.cpuUsage)
    }
    
    private func updatePinnedTitle() {
        guard let button = statusItem.button else { return }
        
        if let pinned = countdownManager.pinnedCountdown {
            if pinned.isCompleted {
                button.title = ""
                // 异步处理，避免在更新 UI 时修改数据导致的刷新循环
                DispatchQueue.main.async {
                    self.countdownManager.unpinIfExpired(id: pinned.id)
                }
            } else {
                let days = pinned.daysRemaining
                button.title = " \(days)天" 
            }
        } else {
            button.title = ""
        }
    }



    @objc func showWindow() {
        let windowWidth: CGFloat = 380
        let windowHeight: CGFloat = 600

        if window == nil {
            createWindow(rect: NSRect.zero)
        }

        // Recalculate position every time to ensure alignment
        if let statusButton = statusItem.button {
            let statusRect = statusButton.window?.frame ?? statusButton.frame
            let screenFrame = NSScreen.main?.visibleFrame ?? NSRect(x: 0, y: 0, width: 1440, height: 900)
            
            var xPos = statusRect.midX - windowWidth / 2
            
            // Fallback for launch issue
            if statusRect.origin.x == 0 && statusRect.origin.y == 0 {
                xPos = screenFrame.maxX - windowWidth - 20
            }
            
            // Constrain visibility
            xPos = max(screenFrame.minX + 10, min(xPos, screenFrame.maxX - windowWidth - 10))
            
            // Y position: Strictly below status bar
            let yPos = statusRect.minY - windowHeight - 5
            
            let windowRect = NSRect(x: xPos, y: yPos, width: windowWidth, height: windowHeight)
            
            window?.setFrame(windowRect, display: true)
        }
        
        window?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true) // Important for focus
        window?.orderFront(nil)
        isWindowVisible = true
        
        setupEventMonitor()
    }

    @objc func hideWindow() {
        window?.orderOut(nil)
        isWindowVisible = false
        stopEventMonitor()
    }

    private func createWindow(rect: NSRect) {
        let contentView = ContentView()
            .environmentObject(countdownManager)
            .environmentObject(aiService)
            .environmentObject(storageManager)
            .environmentObject(systemMonitor)
            .environmentObject(weatherService)

        let hostingController = NSHostingController(rootView: contentView)
        
        let newWindow = CustomWindow(
            contentRect: rect,
            styleMask: [.borderless], // No title bar
            backing: .buffered,
            defer: false
        )
        
        newWindow.contentViewController = hostingController
        newWindow.backgroundColor = .clear
        newWindow.isOpaque = false
        newWindow.title = "Near 倒计时"
        newWindow.isMovableByWindowBackground = false
        newWindow.hasShadow = true
        newWindow.level = .floating
        newWindow.delegate = self
        
        self.window = newWindow
    }
    
    // MARK: - Auto Hide Logic
    
    private func setupEventMonitor() {
        if eventMonitor != nil { return }
        
        eventMonitor = NSEvent.addGlobalMonitorForEvents(matching: [.leftMouseDown, .rightMouseDown]) { [weak self] _ in
            self?.hideWindow()
        }
    }
    
    private func stopEventMonitor() {
        if let monitor = eventMonitor {
            NSEvent.removeMonitor(monitor)
            eventMonitor = nil
        }
    }
    
    // Auto-hide on focus loss
    func windowDidResignKey(_ notification: Notification) {
        hideWindow()
    }
}

class CustomWindow: NSWindow {
    override var canBecomeKey: Bool {
        return true
    }
    
    override var canBecomeMain: Bool {
        return true
    }
}