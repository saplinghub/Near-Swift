import Cocoa
import SwiftUI
import Combine

class StatusBarManager: NSObject, NSWindowDelegate {
    private var statusItem: NSStatusItem
    private var window: NSWindow?
    private var countdownManager: CountdownManager
    private var aiService: AIService
    private var storageManager: StorageManager
    private var systemMonitor: SystemMonitor
    private var eventMonitor: Any?
    private var isWindowVisible = false
    
    // Animation
    private var fanCGImages: [CGImage] = []
    private var iconLayer: CALayer?
    private var cancellables = Set<AnyCancellable>()

    init(countdownManager: CountdownManager, aiService: AIService, storageManager: StorageManager, systemMonitor: SystemMonitor) {
        self.countdownManager = countdownManager
        self.aiService = aiService
        self.storageManager = storageManager
        self.systemMonitor = systemMonitor
        self.statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        super.init()
        
        setupStatusItem()
        loadFanFrames()
        setupAnimationLayer()
        setupBindings()
        
        // Initial Sync
        updatePinnedTitle()
        
        // Show window on launch (Visibility Fix)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.showWindow()
        }
    }
    
    private func setupStatusItem() {
        if let button = statusItem.button {
            // Use a transparent image to reserve layout space (18x18)
            // This ensures text is positioned correctly to the right of our custom layer
            let placeholder = NSImage(size: NSSize(width: 18, height: 18))
            placeholder.isTemplate = false
            button.image = placeholder
            
            button.action = #selector(toggleWindow)
            button.target = self
            button.imagePosition = .imageLeft
            
            // Enable right-click menu
            button.sendAction(on: [.leftMouseDown, .rightMouseUp])
        }
        
        // Setup right-click menu
        let menu = NSMenu()
        menu.addItem(NSMenuItem(title: "打开主窗口", action: #selector(showWindow), keyEquivalent: ""))
        menu.addItem(NSMenuItem.separator())
        menu.addItem(NSMenuItem(title: "退出 Near", action: #selector(quitApp), keyEquivalent: "q"))
        statusItem.menu = nil // Will show on right-click only
        self.statusMenu = menu
    }
    
    private var statusMenu: NSMenu?
    
    @objc func toggleWindow(_ sender: Any?) {
        // Check if it's a right-click
        if let event = NSApp.currentEvent, event.type == .rightMouseUp {
            statusItem.menu = statusMenu
            statusItem.button?.performClick(nil)
            // Reset menu so left-click works
            DispatchQueue.main.async { self.statusItem.menu = nil }
            return
        }
        
        // Left-click behavior
        if isWindowVisible {
            hideWindow()
        } else {
            showWindow()
        }
    }
    
    @objc func quitApp() {
        NSApp.terminate(nil)
    }
    
    private func loadFanFrames() {
        fanCGImages.removeAll()
        
        // 1. Try to find the specific resource bundle if generated by SPM
        var resourceBundle: Bundle?
        
        if let bundlePath = Bundle.main.path(forResource: "NearCountdown_NearCountdown", ofType: "bundle") {
            resourceBundle = Bundle(path: bundlePath)
        } else {
            resourceBundle = Bundle.main
        }
        
        for i in 0...31 {
            let frameName = String(format: "fan_%02d", i)
            var image: NSImage?
            
            if let path = resourceBundle?.path(forResource: frameName, ofType: "png") {
                 image = NSImage(contentsOfFile: path)
            } else if let path = resourceBundle?.path(forResource: frameName, ofType: "png", inDirectory: "icons/fan_frames") {
                 image = NSImage(contentsOfFile: path)
            } else if let path = Bundle.main.path(forResource: frameName, ofType: "png", inDirectory: "NearCountdown_NearCountdown.bundle") {
                 image = NSImage(contentsOfFile: path)
            }
            
            if let img = image {
                // Ensure we get a valid CGImage
                if let tiffData = img.tiffRepresentation,
                   let bitmap = NSBitmapImageRep(data: tiffData),
                   let cgImage = bitmap.cgImage {
                    fanCGImages.append(cgImage)
                } else {
                     // Fallback mechanism
                    var rect = NSRect(origin: .zero, size: img.size)
                    if let cgImage = img.cgImage(forProposedRect: &rect, context: nil, hints: nil) {
                        fanCGImages.append(cgImage)
                    }
                }
            }
        }
        
        if fanCGImages.isEmpty {
            print("Error: No fan frames loaded for animation layer.")
        }
    }
    
    private func setupAnimationLayer() {
        guard !fanCGImages.isEmpty, let button = statusItem.button else { return }
        
        // Ensure UI updates happen on main thread
        DispatchQueue.main.async {
            button.wantsLayer = true
            
            // Clear existing sublayers to prevent dupes
            button.layer?.sublayers?.forEach { $0.removeFromSuperlayer() }
            
            // Create a sublayer for the icon to strictly control size and position
            let layer = CALayer()
            layer.bounds = CGRect(x: 0, y: 0, width: 18, height: 18) // Match icon size
            
            // Position: Center in the standard 22px height button
            // If placeholder is 18x18, we center on that.
            // X: 18/2 + padding (~4?) = 13.
            // Y: 22/2 = 11.
            layer.position = CGPoint(x: 13, y: 11)
            layer.contentsGravity = .resizeAspect
            
            // Important: Add to button's layer
            button.layer?.addSublayer(layer)
            self.iconLayer = layer
            
            // Create the Keyframe Animation
            let animation = CAKeyframeAnimation(keyPath: "contents")
            animation.values = self.fanCGImages
            animation.calculationMode = .discrete // Jump between frames
            animation.duration = 1.0 // 1 second per full rotation (Base speed)
            animation.repeatCount = .infinity
            animation.isRemovedOnCompletion = false
            
            layer.add(animation, forKey: "spin")
            
            // Initialize speed
            layer.speed = 1.0
        }
    }
    
    private func setupBindings() {
        // Observe changes to countdowns to update title
        countdownManager.objectWillChange
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    self?.updatePinnedTitle()
                }
            }
            .store(in: &cancellables)
            
        // Observe System CPU Temperature (not Usage)
        systemMonitor.$cpuTemperature
            .receive(on: DispatchQueue.main)
            .sink { [weak self] temp in
                self?.updateFanSpeed(temperature: temp)
            }
            .store(in: &cancellables)
    }
    
    private func updateFanSpeed(temperature: Double) {
        // Inverse Animation Logic (User Request):
        // "Standard is 30fps. If > 60°C -> 10fps. If > 80°C -> 5fps."
        // Base Duration = 1.0s (32 frames). 
        // Speed 1.0 = ~30 FPS.
        // Speed 0.33 = ~10 FPS.
        // Speed 0.16 = ~5 FPS.
        
        guard let layer = iconLayer else { return }
        
        let targetSpeed: Float
        
        if temperature >= 80.0 {
            targetSpeed = 0.15 // ~5 FPS
        } else if temperature >= 60.0 {
            targetSpeed = 0.31 // ~10 FPS
        } else {
            targetSpeed = 0.93 // ~30 FPS
        }
        
        // Output speed for debugging if needed
        // print("Temp: \(temperature) -> Speed: \(targetSpeed)")
        
        // Smooth update check
        if abs(layer.speed - targetSpeed) > 0.05 {
            layer.speed = targetSpeed
        }
    }
    
    private func updatePinnedTitle() {
        guard let button = statusItem.button else { return }
        
        // Find first pinned countdown
        // Prioritize active, then completed? Usually only active matters for "days remaining" usage.
        if let pinned = countdownManager.pinnedCountdown {
            let days = Calendar.current.dateComponents([.day], from: Date(), to: pinned.targetDate).day ?? 0
            // Format: " 5天"
            // Just simple "X天" as per Tauri
            button.title = " \(days)天" 
        } else {
            button.title = ""
        }
    }



    @objc func showWindow() {
        let windowWidth: CGFloat = 380
        let windowHeight: CGFloat = 600

        if window == nil {
            createWindow(rect: NSRect.zero)
        }

        // Recalculate position every time to ensure alignment
        if let statusButton = statusItem.button {
            let statusRect = statusButton.window?.frame ?? statusButton.frame
            let screenFrame = NSScreen.main?.visibleFrame ?? NSRect(x: 0, y: 0, width: 1440, height: 900)
            
            var xPos = statusRect.midX - windowWidth / 2
            
            // Fallback for launch issue
            if statusRect.origin.x == 0 && statusRect.origin.y == 0 {
                xPos = screenFrame.maxX - windowWidth - 20
            }
            
            // Constrain visibility
            xPos = max(screenFrame.minX + 10, min(xPos, screenFrame.maxX - windowWidth - 10))
            
            // Y position: Strictly below status bar
            let yPos = statusRect.minY - windowHeight - 5
            
            let windowRect = NSRect(x: xPos, y: yPos, width: windowWidth, height: windowHeight)
            
            window?.setFrame(windowRect, display: true)
        }
        
        window?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true) // Important for focus
        window?.orderFront(nil)
        isWindowVisible = true
        
        setupEventMonitor()
    }

    func hideWindow() {
        window?.orderOut(nil)
        isWindowVisible = false
        stopEventMonitor()
    }

    private func createWindow(rect: NSRect) {
        let contentView = ContentView()
            .environmentObject(countdownManager)
            .environmentObject(aiService)
            .environmentObject(storageManager)
            .environmentObject(systemMonitor)

        let hostingController = NSHostingController(rootView: contentView)
        
        let newWindow = CustomWindow(
            contentRect: rect,
            styleMask: [.borderless], // No title bar
            backing: .buffered,
            defer: false
        )
        
        newWindow.contentViewController = hostingController
        newWindow.backgroundColor = .clear
        newWindow.isOpaque = false
        newWindow.title = "Near 倒计时"
        newWindow.isMovableByWindowBackground = false
        newWindow.hasShadow = true
        newWindow.level = .floating
        newWindow.delegate = self
        
        self.window = newWindow
    }
    
    // MARK: - Auto Hide Logic
    
    private func setupEventMonitor() {
        if eventMonitor != nil { return }
        
        eventMonitor = NSEvent.addGlobalMonitorForEvents(matching: [.leftMouseDown, .rightMouseDown]) { [weak self] _ in
            self?.hideWindow()
        }
    }
    
    private func stopEventMonitor() {
        if let monitor = eventMonitor {
            NSEvent.removeMonitor(monitor)
            eventMonitor = nil
        }
    }
    
    // Auto-hide on focus loss
    func windowDidResignKey(_ notification: Notification) {
        hideWindow()
    }
}

class CustomWindow: NSWindow {
    override var canBecomeKey: Bool {
        return true
    }
    
    override var canBecomeMain: Bool {
        return true
    }
}